import { HttpParams } from '@angular/common/http';
import { stringify } from 'qs';

class RequestQueryException extends Error {
    constructor(msg) {
        super(msg);
    }
}

const objKeys = (val) => Object.keys(val);
const getOwnPropNames = (val) => Object.getOwnPropertyNames(val);

const isUndefined = (val) => typeof val === 'undefined';
const isNull = (val) => val === null;
const isNil = (val) => isUndefined(val) || isNull(val);
const isString = (val) => typeof val === 'string';
const hasLength = (val) => val.length > 0;
const isStringFull = (val) => isString(val) && hasLength(val);
const isArrayFull = (val) => Array.isArray(val) && hasLength(val);
const isArrayStrings = (val) => isArrayFull(val) && val.every((v) => isStringFull(v));
const isObject = (val) => typeof val === 'object' && !isNull(val);
const isObjectFull = (val) => isObject(val) && hasLength(objKeys(val));
const isNumber = (val) => typeof val === 'number' && !Number.isNaN(val) && Number.isFinite(val);
const isEqual = (val, eq) => val === eq;
const isFalse = (val) => val === false;
const isTrue = (val) => val === true;
const isIn = (val, arr = []) => arr.some((o) => isEqual(val, o));
const isBoolean = (val) => typeof val === 'boolean';
const isNumeric = (val) => /^[+-]?([0-9]*[.])?[0-9]+$/.test(val);
const isDateString = (val) => isStringFull(val) &&
    /^\d{4}-[01]\d-[0-3]\d(?:T[0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?(?:Z|[-+][0-2]\d(?::?[0-5]\d)?)?)?$/g.test(val);
const isDate = (val) => val instanceof Date;
const isValue = (val) => isStringFull(val) || isNumber(val) || isBoolean(val) || isDate(val);
const hasValue = (val) => isArrayFull(val) ? val.every((o) => isValue(o)) : isValue(val);
const isFunction = (val) => typeof val === 'function';

var CondOperator;
(function (CondOperator) {
    CondOperator["EQUALS"] = "$eq";
    CondOperator["NOT_EQUALS"] = "$ne";
    CondOperator["GREATER_THAN"] = "$gt";
    CondOperator["LOWER_THAN"] = "$lt";
    CondOperator["GREATER_THAN_EQUALS"] = "$gte";
    CondOperator["LOWER_THAN_EQUALS"] = "$lte";
    CondOperator["STARTS"] = "$starts";
    CondOperator["ENDS"] = "$ends";
    CondOperator["CONTAINS"] = "$cont";
    CondOperator["EXCLUDES"] = "$excl";
    CondOperator["IN"] = "$in";
    CondOperator["NOT_IN"] = "$notin";
    CondOperator["IS_NULL"] = "$isnull";
    CondOperator["NOT_NULL"] = "$notnull";
    CondOperator["BETWEEN"] = "$between";
    CondOperator["EQUALS_LOW"] = "$eqL";
    CondOperator["NOT_EQUALS_LOW"] = "$neL";
    CondOperator["STARTS_LOW"] = "$startsL";
    CondOperator["ENDS_LOW"] = "$endsL";
    CondOperator["CONTAINS_LOW"] = "$contL";
    CondOperator["EXCLUDES_LOW"] = "$exclL";
    CondOperator["IN_LOW"] = "$inL";
    CondOperator["NOT_IN_LOW"] = "$notinL";
})(CondOperator || (CondOperator = {}));

const deprecatedComparisonOperatorsList = [
    'eq',
    'ne',
    'gt',
    'lt',
    'gte',
    'lte',
    'starts',
    'ends',
    'cont',
    'excl',
    'in',
    'notin',
    'isnull',
    'notnull',
    'between',
];
const ɵ0 = (n) => CondOperator[n];
const comparisonOperatorsList = Object.assign(deprecatedComparisonOperatorsList, objKeys(CondOperator).map(ɵ0));
const sortOrdersList = ['ASC', 'DESC'];
const comparisonOperatorsListStr = comparisonOperatorsList.join();
const sortOrdersListStr = sortOrdersList.join();
function validateFields(fields) {
    if (!isArrayStrings(fields)) {
        throw new RequestQueryException('Invalid fields. Array of strings expected');
    }
}
function validateCondition(val, cond) {
    if (!isObject(val) || !isStringFull(val.field)) {
        throw new RequestQueryException(`Invalid field type in ${cond} condition. String expected`);
    }
    validateComparisonOperator(val.operator);
}
function validateComparisonOperator(operator) {
    if (!comparisonOperatorsList.includes(operator)) {
        throw new RequestQueryException(`Invalid comparison operator. ${comparisonOperatorsListStr} expected`);
    }
}
function validateJoin(join) {
    if (!isObject(join) || !isStringFull(join.field)) {
        throw new RequestQueryException('Invalid join field. String expected');
    }
    if (!isUndefined(join.select) && !isArrayStrings(join.select)) {
        throw new RequestQueryException('Invalid join select. Array of strings expected');
    }
}
function validateSort(sort) {
    if (!isObject(sort) || !isStringFull(sort.field)) {
        throw new RequestQueryException('Invalid sort field. String expected');
    }
    if (!isEqual(sort.order, sortOrdersList[0]) &&
        !isEqual(sort.order, sortOrdersList[1])) {
        throw new RequestQueryException(`Invalid sort order. ${sortOrdersListStr} expected`);
    }
}
function validateNumeric(val, num) {
    if (!isNumber(val)) {
        throw new RequestQueryException(`Invalid ${num}. Number expected`);
    }
}
function validateParamOption(options, name) {
    if (!isObject(options)) {
        throw new RequestQueryException(`Invalid param ${name}. Invalid crud options`);
    }
    const option = options[name];
    if (option && option.disabled) {
        return;
    }
    if (!isObject(option) || isNil(option.field) || isNil(option.type)) {
        throw new RequestQueryException(`Invalid param option in Crud`);
    }
}
function validateUUID(str, name) {
    const uuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    const uuidV4 = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    if (!uuidV4.test(str) && !uuid.test(str)) {
        throw new RequestQueryException(`Invalid param ${name}. UUID string expected`);
    }
}

// tslint:disable:variable-name ban-types
class RequestQueryBuilder {
    constructor() {
        this.paramNames = {};
        this.queryObject = {};
        this.setParamNames();
    }
    static setOptions(options) {
        RequestQueryBuilder._options = Object.assign(Object.assign(Object.assign({}, RequestQueryBuilder._options), options), { paramNamesMap: Object.assign(Object.assign({}, RequestQueryBuilder._options.paramNamesMap), (options.paramNamesMap ? options.paramNamesMap : {})) });
    }
    static getOptions() {
        return RequestQueryBuilder._options;
    }
    static create(params) {
        const qb = new RequestQueryBuilder();
        return isObject(params) ? qb.createFromParams(params) : qb;
    }
    get options() {
        return RequestQueryBuilder._options;
    }
    setParamNames() {
        Object.keys(RequestQueryBuilder._options.paramNamesMap).forEach((key) => {
            const name = RequestQueryBuilder._options.paramNamesMap[key];
            this.paramNames[key] = isString(name) ? name : name[0];
        });
    }
    query(encode = true) {
        if (this.queryObject[this.paramNames.search]) {
            this.queryObject[this.paramNames.filter] = undefined;
            this.queryObject[this.paramNames.or] = undefined;
        }
        this.queryString = stringify(this.queryObject, { encode });
        return this.queryString;
    }
    select(fields) {
        if (isArrayFull(fields)) {
            validateFields(fields);
            this.queryObject[this.paramNames.fields] = fields.join(this.options.delimStr);
        }
        return this;
    }
    search(s) {
        if (!isNil(s) && isObject(s)) {
            this.queryObject[this.paramNames.search] = JSON.stringify(s);
        }
        return this;
    }
    setFilter(f) {
        this.setCondition(f, 'filter');
        return this;
    }
    setOr(f) {
        this.setCondition(f, 'or');
        return this;
    }
    setJoin(j) {
        if (!isNil(j)) {
            const param = this.checkQueryObjectParam('join', []);
            this.queryObject[param] = [
                ...this.queryObject[param],
                ...(Array.isArray(j) && !isString(j[0])
                    ? j.map((o) => this.addJoin(o))
                    : [this.addJoin(j)]),
            ];
        }
        return this;
    }
    sortBy(s) {
        if (!isNil(s)) {
            const param = this.checkQueryObjectParam('sort', []);
            this.queryObject[param] = [
                ...this.queryObject[param],
                ...(Array.isArray(s) && !isString(s[0])
                    ? s.map((o) => this.addSortBy(o))
                    : [this.addSortBy(s)]),
            ];
        }
        return this;
    }
    setLimit(n) {
        this.setNumeric(n, 'limit');
        return this;
    }
    setOffset(n) {
        this.setNumeric(n, 'offset');
        return this;
    }
    setPage(n) {
        this.setNumeric(n, 'page');
        return this;
    }
    resetCache() {
        this.setNumeric(0, 'cache');
        return this;
    }
    cond(f, cond = 'search') {
        const filter = Array.isArray(f) ? { field: f[0], operator: f[1], value: f[2] } : f;
        validateCondition(filter, cond);
        const d = this.options.delim;
        return (filter.field +
            d +
            filter.operator +
            (hasValue(filter.value) ? d + filter.value : ''));
    }
    addJoin(j) {
        const join = Array.isArray(j) ? { field: j[0], select: j[1] } : j;
        validateJoin(join);
        const d = this.options.delim;
        const ds = this.options.delimStr;
        return join.field + (isArrayFull(join.select) ? d + join.select.join(ds) : '');
    }
    addSortBy(s) {
        const sort = Array.isArray(s) ? { field: s[0], order: s[1] } : s;
        validateSort(sort);
        const ds = this.options.delimStr;
        return sort.field + ds + sort.order;
    }
    createFromParams(params) {
        this.select(params.fields);
        this.search(params.search);
        this.setFilter(params.filter);
        this.setOr(params.or);
        this.setJoin(params.join);
        this.setLimit(params.limit);
        this.setOffset(params.offset);
        this.setPage(params.page);
        this.sortBy(params.sort);
        if (params.resetCache) {
            this.resetCache();
        }
        return this;
    }
    checkQueryObjectParam(cond, defaults) {
        const param = this.paramNames[cond];
        if (isNil(this.queryObject[param]) && !isUndefined(defaults)) {
            this.queryObject[param] = defaults;
        }
        return param;
    }
    setCondition(f, cond) {
        if (!isNil(f)) {
            const param = this.checkQueryObjectParam(cond, []);
            this.queryObject[param] = [
                ...this.queryObject[param],
                ...(Array.isArray(f) && !isString(f[0])
                    ? f.map((o) => this.cond(o, cond))
                    : [this.cond(f, cond)]),
            ];
        }
    }
    setNumeric(n, cond) {
        if (!isNil(n)) {
            validateNumeric(n, cond);
            this.queryObject[this.paramNames[cond]] = n;
        }
    }
}
RequestQueryBuilder._options = {
    delim: '||',
    delimStr: ',',
    paramNamesMap: {
        fields: ['fields', 'select'],
        search: 's',
        filter: 'filter',
        or: 'or',
        join: 'join',
        sort: 'sort',
        limit: ['limit', 'per_page'],
        offset: 'offset',
        page: 'page',
        cache: 'cache',
    },
};

// tslint:disable:variable-name ban-types
class RequestQueryParser {
    constructor() {
        this.fields = [];
        this.paramsFilter = [];
        this.authPersist = undefined;
        this.filter = [];
        this.or = [];
        this.join = [];
        this.sort = [];
    }
    get _options() {
        return RequestQueryBuilder.getOptions();
    }
    static create() {
        return new RequestQueryParser();
    }
    getParsed() {
        return {
            fields: this.fields,
            paramsFilter: this.paramsFilter,
            authPersist: this.authPersist,
            search: this.search,
            filter: this.filter,
            or: this.or,
            join: this.join,
            sort: this.sort,
            limit: this.limit,
            offset: this.offset,
            page: this.page,
            cache: this.cache,
        };
    }
    parseQuery(query) {
        if (isObject(query)) {
            const paramNames = objKeys(query);
            if (hasLength(paramNames)) {
                this._query = query;
                this._paramNames = paramNames;
                let searchData = this._query[this.getParamNames('search')[0]];
                this.search = this.parseSearchQueryParam(searchData);
                if (isNil(this.search)) {
                    this.filter = this.parseQueryParam('filter', this.conditionParser.bind(this, 'filter'));
                    this.or = this.parseQueryParam('or', this.conditionParser.bind(this, 'or'));
                }
                this.fields =
                    this.parseQueryParam('fields', this.fieldsParser.bind(this))[0] || [];
                this.join = this.parseQueryParam('join', this.joinParser.bind(this));
                this.sort = this.parseQueryParam('sort', this.sortParser.bind(this));
                this.limit = this.parseQueryParam('limit', this.numericParser.bind(this, 'limit'))[0];
                this.offset = this.parseQueryParam('offset', this.numericParser.bind(this, 'offset'))[0];
                this.page = this.parseQueryParam('page', this.numericParser.bind(this, 'page'))[0];
                this.cache = this.parseQueryParam('cache', this.numericParser.bind(this, 'cache'))[0];
            }
        }
        return this;
    }
    parseParams(params, options) {
        if (isObject(params)) {
            const paramNames = objKeys(params);
            if (hasLength(paramNames)) {
                this._params = params;
                this._paramsOptions = options;
                this.paramsFilter = paramNames
                    .map((name) => this.paramParser(name))
                    .filter((filter) => filter);
            }
        }
        return this;
    }
    setAuthPersist(persist = {}) {
        this.authPersist = persist || /* istanbul ignore next */ {};
    }
    convertFilterToSearch(filter) {
        const isEmptyValue = {
            isnull: true,
            notnull: true,
        };
        return filter
            ? {
                [filter.field]: {
                    [filter.operator]: isEmptyValue[filter.operator]
                        ? isEmptyValue[filter.operator]
                        : filter.value,
                },
            }
            : /* istanbul ignore next */ {};
    }
    getParamNames(type) {
        return this._paramNames.filter((p) => {
            const name = this._options.paramNamesMap[type];
            return isString(name) ? name === p : name.some((m) => m === p);
        });
    }
    getParamValues(value, parser) {
        if (isStringFull(value)) {
            return [parser.call(this, value)];
        }
        if (isArrayFull(value)) {
            return value.map((val) => parser(val));
        }
        return [];
    }
    parseQueryParam(type, parser) {
        const param = this.getParamNames(type);
        if (isArrayFull(param)) {
            return param.reduce((a, name) => Object.assign(a, this.getParamValues(this._query[name], parser)), []);
        }
        return [];
    }
    parseValue(val) {
        try {
            const parsed = JSON.parse(val);
            if (!isDate(parsed) && isObject(parsed)) {
                // throw new Error('Don\'t support object now');
                return val;
            }
            else if (typeof parsed === 'number' &&
                parsed.toLocaleString('fullwide', { useGrouping: false }) !== val) {
                // JS cannot handle big numbers. Leave it as a string to prevent data loss
                return val;
            }
            return parsed;
        }
        catch (ignored) {
            if (isDateString(val)) {
                return new Date(val);
            }
            return val;
        }
    }
    parseValues(vals) {
        if (isArrayFull(vals)) {
            return vals.map((v) => this.parseValue(v));
        }
        else {
            return this.parseValue(vals);
        }
    }
    fieldsParser(data) {
        return data.split(this._options.delimStr);
    }
    parseSearchQueryParam(d) {
        try {
            if (isNil(d)) {
                return undefined;
            }
            const data = JSON.parse(d);
            if (!isObject(data)) {
                throw new Error();
            }
            return data;
        }
        catch (_) {
            throw new RequestQueryException('Invalid search param. JSON expected');
        }
    }
    conditionParser(cond, data) {
        const isArrayValue = [
            'in',
            'notin',
            'between',
            '$in',
            '$notin',
            '$between',
            '$inL',
            '$notinL',
        ];
        const isEmptyValue = ['isnull', 'notnull', '$isnull', '$notnull'];
        const param = data.split(this._options.delim);
        const field = param[0];
        const operator = param[1];
        let value = param[2] || '';
        if (isArrayValue.some((name) => name === operator)) {
            value = value.split(this._options.delimStr);
        }
        value = this.parseValues(value);
        if (!isEmptyValue.some((name) => name === operator) && !hasValue(value)) {
            throw new RequestQueryException(`Invalid ${cond} value`);
        }
        const condition = { field, operator, value };
        validateCondition(condition, cond);
        return condition;
    }
    joinParser(data) {
        const param = data.split(this._options.delim);
        const join = {
            field: param[0],
            select: isStringFull(param[1]) ? param[1].split(this._options.delimStr) : undefined,
        };
        validateJoin(join);
        return join;
    }
    sortParser(data) {
        const param = data.split(this._options.delimStr);
        const sort = {
            field: param[0],
            order: param[1],
        };
        validateSort(sort);
        return sort;
    }
    numericParser(num, data) {
        const val = this.parseValue(data);
        validateNumeric(val, num);
        return val;
    }
    paramParser(name) {
        validateParamOption(this._paramsOptions, name);
        const option = this._paramsOptions[name];
        if (option.disabled) {
            return undefined;
        }
        let value = this._params[name];
        switch (option.type) {
            case 'number':
                value = this.parseValue(value);
                validateNumeric(value, `param ${name}`);
                break;
            case 'uuid':
                validateUUID(value, name);
                break;
            default:
                break;
        }
        return { field: option.field, operator: '$eq', value };
    }
}

class CrudBaseService {
    constructor(options, http) {
        this.http = http;
        this.options = options;
    }
    getPagination(limit, page, builder) {
        if (!builder) {
            builder = RequestQueryBuilder.create();
        }
        else if (!(builder instanceof RequestQueryBuilder)) {
            builder = RequestQueryBuilder.create(builder);
        }
        builder.setLimit(limit);
        builder.setPage(page);
        return this.http.get(this.getBaseUrl(), {
            params: this.getParamsFromQuery(builder),
        });
    }
    getMany(builder) {
        return this.http.get(this.getBaseUrl(), {
            params: this.getParamsFromQuery(builder),
        });
    }
    getOne(value, builder) {
        const url = this.getOneUrl(value);
        return this.http.get(url, {
            params: this.getParamsFromQuery(builder),
        });
    }
    create(body) {
        return this.http.post(this.getBaseUrl(), JSON.stringify(body), {
            headers: {
                'Content-Type': 'application/json',
            },
        });
    }
    createMany(body) {
        return this.http.post(this.getBaseUrl() + '/bulk', JSON.stringify({ bulk: body }), {
            headers: {
                'Content-Type': 'application/json',
            },
        });
    }
    put(value, body) {
        const url = this.getOneUrl(value);
        return this.http.put(url, JSON.stringify(body), {
            headers: {
                'Content-Type': 'application/json',
            },
        });
    }
    patch(value, body) {
        const url = this.getOneUrl(value);
        return this.http.patch(url, JSON.stringify(body), {
            headers: {
                'Content-Type': 'application/json',
            },
        });
    }
    delete(value) {
        const url = this.getOneUrl(value);
        return this.http.delete(url);
    }
    getParamsFromQuery(builder) {
        if (!(builder instanceof RequestQueryBuilder)) {
            builder = RequestQueryBuilder.create(builder);
        }
        return new HttpParams({ fromString: this.getQuery(builder) });
    }
    /**
     * Get request link
     */
    getBaseUrl() {
        return `${this.options.apiUrl}/${this.options.entity}`;
    }
    getOneUrl(value) {
        return `${this.getBaseUrl()}/${value}`;
    }
    getQuery(builder) {
        if (builder) {
            return builder.query();
        }
        return '';
    }
}

/*
 * Public API Surface of nest-crud-typeorm-client
 */

/**
 * Generated bundle index. Do not edit.
 */

export { CondOperator, CrudBaseService, RequestQueryBuilder, RequestQueryException, RequestQueryParser, getOwnPropNames, hasLength, hasValue, isArrayFull, isArrayStrings, isBoolean, isDate, isDateString, isEqual, isFalse, isFunction, isIn, isNil, isNull, isNumber, isNumeric, isObject, isObjectFull, isString, isStringFull, isTrue, isUndefined, isValue, objKeys };
//# sourceMappingURL=nest-crud-typeorm-client.js.map
