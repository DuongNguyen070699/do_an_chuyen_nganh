{"ast":null,"code":"import * as ɵngcc0 from '@angular/core';\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nimport { Injectable } from '@angular/core';\nimport { observable, computed, action, autorun, reaction } from 'mobx';\nimport { TreeModel } from './tree.model';\nimport { TREE_EVENTS } from '../constants/events';\nvar Y_OFFSET = 500; // Extra pixels outside the viewport, in each direction, to render nodes in\n\nvar Y_EPSILON = 150; // Minimum pixel change required to recalculate the rendered nodes\n\nvar TreeVirtualScroll =\n/** @class */\nfunction () {\n  function TreeVirtualScroll(treeModel) {\n    var _this = this;\n\n    this.treeModel = treeModel;\n    this.yBlocks = 0;\n    this.x = 0;\n    this.viewportHeight = null;\n    this.viewport = null;\n    treeModel.virtualScroll = this;\n    this._dispose = [autorun(function () {\n      return _this.fixScroll();\n    })];\n  }\n\n  Object.defineProperty(TreeVirtualScroll.prototype, \"y\", {\n    get: function get() {\n      return this.yBlocks * Y_EPSILON;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TreeVirtualScroll.prototype, \"totalHeight\", {\n    get: function get() {\n      return this.treeModel.virtualRoot ? this.treeModel.virtualRoot.height : 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  TreeVirtualScroll.prototype.fireEvent = function (event) {\n    this.treeModel.fireEvent(event);\n  };\n\n  TreeVirtualScroll.prototype.init = function () {\n    var _this = this;\n\n    var fn = this.recalcPositions.bind(this);\n    fn();\n    this._dispose = this._dispose.concat([reaction(function () {\n      return _this.treeModel.roots;\n    }, fn), reaction(function () {\n      return _this.treeModel.expandedNodeIds;\n    }, fn), reaction(function () {\n      return _this.treeModel.hiddenNodeIds;\n    }, fn)]);\n    this.treeModel.subscribe(TREE_EVENTS.loadNodeChildren, fn);\n  };\n\n  TreeVirtualScroll.prototype.isEnabled = function () {\n    return this.treeModel.options.useVirtualScroll;\n  };\n\n  TreeVirtualScroll.prototype._setYBlocks = function (value) {\n    this.yBlocks = value;\n  };\n\n  TreeVirtualScroll.prototype.recalcPositions = function () {\n    this.treeModel.virtualRoot.height = this._getPositionAfter(this.treeModel.getVisibleRoots(), 0);\n  };\n\n  TreeVirtualScroll.prototype._getPositionAfter = function (nodes, startPos) {\n    var _this = this;\n\n    var position = startPos;\n    nodes.forEach(function (node) {\n      node.position = position;\n      position = _this._getPositionAfterNode(node, position);\n    });\n    return position;\n  };\n\n  TreeVirtualScroll.prototype._getPositionAfterNode = function (node, startPos) {\n    var position = node.getSelfHeight() + startPos;\n\n    if (node.children && node.isExpanded) {\n      // TBD: consider loading component as well\n      position = this._getPositionAfter(node.visibleChildren, position);\n    }\n\n    node.height = position - startPos;\n    return position;\n  };\n\n  TreeVirtualScroll.prototype.clear = function () {\n    this._dispose.forEach(function (d) {\n      return d();\n    });\n  };\n\n  TreeVirtualScroll.prototype.setViewport = function (viewport) {\n    Object.assign(this, {\n      viewport: viewport,\n      x: viewport.scrollLeft,\n      yBlocks: Math.round(viewport.scrollTop / Y_EPSILON),\n      viewportHeight: viewport.getBoundingClientRect ? viewport.getBoundingClientRect().height : 0\n    });\n  };\n\n  TreeVirtualScroll.prototype.scrollIntoView = function (node, force, scrollToMiddle) {\n    if (scrollToMiddle === void 0) {\n      scrollToMiddle = true;\n    }\n\n    if (node.options.scrollContainer) {\n      var scrollContainer = node.options.scrollContainer;\n      var scrollContainerHeight = scrollContainer.getBoundingClientRect().height;\n      var scrollContainerTop = scrollContainer.getBoundingClientRect().top;\n      var nodeTop = this.viewport.getBoundingClientRect().top + node.position - scrollContainerTop;\n\n      if (force || // force scroll to node\n      nodeTop < scrollContainer.scrollTop || // node is above scroll container\n      nodeTop + node.getSelfHeight() > scrollContainer.scrollTop + scrollContainerHeight) {\n        // node is below container\n        scrollContainer.scrollTop = scrollToMiddle ? nodeTop - scrollContainerHeight / 2 : // scroll to middle\n        nodeTop; // scroll to start\n      }\n    } else {\n      if (force || // force scroll to node\n      node.position < this.y || // node is above viewport\n      node.position + node.getSelfHeight() > this.y + this.viewportHeight) {\n        // node is below viewport\n        if (this.viewport) {\n          this.viewport.scrollTop = scrollToMiddle ? node.position - this.viewportHeight / 2 : // scroll to middle\n          node.position; // scroll to start\n\n          this._setYBlocks(Math.floor(this.viewport.scrollTop / Y_EPSILON));\n        }\n      }\n    }\n  };\n\n  TreeVirtualScroll.prototype.getViewportNodes = function (nodes) {\n    var _this = this;\n\n    if (!nodes) return [];\n    var visibleNodes = nodes.filter(function (node) {\n      return !node.isHidden;\n    });\n    if (!this.isEnabled()) return visibleNodes;\n    if (!this.viewportHeight || !visibleNodes.length) return []; // Search for first node in the viewport using binary search\n    // Look for first node that starts after the beginning of the viewport (with buffer)\n    // Or that ends after the beginning of the viewport\n\n    var firstIndex = binarySearch(visibleNodes, function (node) {\n      return node.position + Y_OFFSET > _this.y || node.position + node.height > _this.y;\n    }); // Search for last node in the viewport using binary search\n    // Look for first node that starts after the end of the viewport (with buffer)\n\n    var lastIndex = binarySearch(visibleNodes, function (node) {\n      return node.position - Y_OFFSET > _this.y + _this.viewportHeight;\n    }, firstIndex);\n    var viewportNodes = []; // Loading async top nodes' children is too long.\n    // It happens when first node is visible withing viewport range (including Y_OFFSET).\n    // In that case firstIndex == 0 and lastIndex == visibleNodes.length - 1 (e.g. 1000),\n    // which means that it loops through every visibleNodes item and push them into viewportNodes array.\n    // lastIndex should not equal visibleNodes.length - 1, but something around 50-100 (depending on the viewport)\n\n    var nodeHeight = visibleNodes[0].treeModel.options.options.nodeHeight;\n    var renderedNodesMaxLength = (Y_OFFSET * 2 + this.viewportHeight) / nodeHeight; // Something is probably wrong, prevent nodes from being pushed to an array.\n\n    if (lastIndex - firstIndex > renderedNodesMaxLength) {\n      return [];\n    }\n\n    for (var i = firstIndex; i <= lastIndex; i++) {\n      viewportNodes.push(visibleNodes[i]);\n    }\n\n    return viewportNodes;\n  };\n\n  TreeVirtualScroll.prototype.fixScroll = function () {\n    var maxY = Math.max(0, this.totalHeight - this.viewportHeight);\n    if (this.y < 0) this._setYBlocks(0);\n    if (this.y > maxY) this._setYBlocks(maxY / Y_EPSILON);\n  };\n\n  __decorate([observable, __metadata(\"design:type\", Object)], TreeVirtualScroll.prototype, \"yBlocks\", void 0);\n\n  __decorate([observable, __metadata(\"design:type\", Object)], TreeVirtualScroll.prototype, \"x\", void 0);\n\n  __decorate([observable, __metadata(\"design:type\", Object)], TreeVirtualScroll.prototype, \"viewportHeight\", void 0);\n\n  __decorate([computed, __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [])], TreeVirtualScroll.prototype, \"y\", null);\n\n  __decorate([computed, __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [])], TreeVirtualScroll.prototype, \"totalHeight\", null);\n\n  __decorate([action, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", void 0)], TreeVirtualScroll.prototype, \"_setYBlocks\", null);\n\n  __decorate([action, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], TreeVirtualScroll.prototype, \"recalcPositions\", null);\n\n  __decorate([action, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", void 0)], TreeVirtualScroll.prototype, \"setViewport\", null);\n\n  __decorate([action, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object, Object, Object]), __metadata(\"design:returntype\", void 0)], TreeVirtualScroll.prototype, \"scrollIntoView\", null);\n\n  TreeVirtualScroll = __decorate([__metadata(\"design:paramtypes\", [TreeModel])], TreeVirtualScroll);\n\n  TreeVirtualScroll.ɵfac = function TreeVirtualScroll_Factory(t) {\n    return new (t || TreeVirtualScroll)(ɵngcc0.ɵɵinject(TreeModel));\n  };\n\n  TreeVirtualScroll.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n    token: TreeVirtualScroll,\n    factory: function factory(t) {\n      return TreeVirtualScroll.ɵfac(t);\n    }\n  });\n  /*@__PURE__*/\n\n  (function () {\n    ɵngcc0.ɵsetClassMetadata(TreeVirtualScroll, [{\n      type: Injectable\n    }], function () {\n      return [{\n        type: TreeModel\n      }];\n    }, null);\n  })();\n\n  return TreeVirtualScroll;\n}();\n\nexport { TreeVirtualScroll };\n\nfunction binarySearch(nodes, condition, firstIndex) {\n  if (firstIndex === void 0) {\n    firstIndex = 0;\n  }\n\n  var index = firstIndex;\n  var toIndex = nodes.length - 1;\n\n  while (index !== toIndex) {\n    var midIndex = Math.floor((index + toIndex) / 2);\n\n    if (condition(nodes[midIndex])) {\n      toIndex = midIndex;\n    } else {\n      if (index === midIndex) index = toIndex;else index = midIndex;\n    }\n  }\n\n  return index;\n}","map":{"version":3,"sources":["../../lib/models/tree-virtual-scroll.model.ts"],"names":[],"mappings":"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","sourcesContent":["import { Injectable } from '@angular/core';\nimport { observable, computed, action, autorun, reaction } from 'mobx';\nimport { TreeModel } from './tree.model';\nimport { TREE_EVENTS } from '../constants/events';\n\nconst Y_OFFSET = 500; // Extra pixels outside the viewport, in each direction, to render nodes in\nconst Y_EPSILON = 150; // Minimum pixel change required to recalculate the rendered nodes\n\n@Injectable()\nexport class TreeVirtualScroll {\n  private _dispose: any;\n\n  @observable yBlocks = 0;\n  @observable x = 0;\n  @observable viewportHeight = null;\n  viewport = null;\n\n  @computed get y() {\n    return this.yBlocks * Y_EPSILON;\n  }\n\n  @computed get totalHeight() {\n    return this.treeModel.virtualRoot ? this.treeModel.virtualRoot.height : 0;\n  }\n\n  constructor(private treeModel: TreeModel) {\n    treeModel.virtualScroll = this;\n    this._dispose = [autorun(() => this.fixScroll())];\n  }\n\n  fireEvent(event) {\n    this.treeModel.fireEvent(event);\n  }\n\n  init() {\n    const fn = this.recalcPositions.bind(this);\n\n    fn();\n    this._dispose = [\n      ...this._dispose,\n      reaction(() => this.treeModel.roots, fn),\n      reaction(() => this.treeModel.expandedNodeIds, fn),\n      reaction(() => this.treeModel.hiddenNodeIds, fn)\n    ];\n    this.treeModel.subscribe(TREE_EVENTS.loadNodeChildren, fn);\n  }\n\n  isEnabled() {\n    return this.treeModel.options.useVirtualScroll;\n  }\n\n  @action private _setYBlocks(value) {\n    this.yBlocks = value;\n  }\n\n  @action recalcPositions() {\n    this.treeModel.virtualRoot.height = this._getPositionAfter(this.treeModel.getVisibleRoots(), 0);\n  }\n\n  private _getPositionAfter(nodes, startPos) {\n    let position = startPos;\n\n    nodes.forEach((node) => {\n      node.position = position;\n      position = this._getPositionAfterNode(node, position);\n    });\n    return position;\n  }\n\n  private _getPositionAfterNode(node, startPos) {\n    let position = node.getSelfHeight() + startPos;\n\n    if (node.children && node.isExpanded) { // TBD: consider loading component as well\n      position = this._getPositionAfter(node.visibleChildren, position);\n    }\n    node.height = position - startPos;\n    return position;\n  }\n\n\n  clear() {\n    this._dispose.forEach((d) => d());\n  }\n\n  @action setViewport(viewport) {\n    Object.assign(this, {\n      viewport,\n      x: viewport.scrollLeft,\n      yBlocks: Math.round(viewport.scrollTop / Y_EPSILON),\n      viewportHeight: viewport.getBoundingClientRect ? viewport.getBoundingClientRect().height : 0\n    });\n  }\n\n  @action scrollIntoView(node, force, scrollToMiddle = true) {\n    if (node.options.scrollContainer) {\n      const scrollContainer = node.options.scrollContainer;\n      const scrollContainerHeight = scrollContainer.getBoundingClientRect().height;\n      const scrollContainerTop = scrollContainer.getBoundingClientRect().top;\n      const nodeTop = this.viewport.getBoundingClientRect().top + node.position - scrollContainerTop;\n\n      if (force || // force scroll to node\n        nodeTop < scrollContainer.scrollTop || // node is above scroll container\n        nodeTop + node.getSelfHeight() > scrollContainer.scrollTop + scrollContainerHeight) { // node is below container\n        scrollContainer.scrollTop = scrollToMiddle ?\n          nodeTop - scrollContainerHeight / 2 : // scroll to middle\n          nodeTop; // scroll to start\n      }\n    } else {\n      if (force || // force scroll to node\n        node.position < this.y || // node is above viewport\n        node.position + node.getSelfHeight() > this.y + this.viewportHeight) { // node is below viewport\n        if (this.viewport) {\n          this.viewport.scrollTop = scrollToMiddle ?\n          node.position - this.viewportHeight / 2 : // scroll to middle\n          node.position; // scroll to start\n\n          this._setYBlocks(Math.floor(this.viewport.scrollTop / Y_EPSILON));\n        }\n      }\n    }\n  }\n\n  getViewportNodes(nodes) {\n    if (!nodes) return [];\n\n    const visibleNodes = nodes.filter((node) => !node.isHidden);\n\n    if (!this.isEnabled()) return visibleNodes;\n\n    if (!this.viewportHeight || !visibleNodes.length) return [];\n\n    // Search for first node in the viewport using binary search\n    // Look for first node that starts after the beginning of the viewport (with buffer)\n    // Or that ends after the beginning of the viewport\n    const firstIndex = binarySearch(visibleNodes, (node) => {\n      return (node.position + Y_OFFSET > this.y) ||\n             (node.position + node.height > this.y);\n    });\n\n    // Search for last node in the viewport using binary search\n    // Look for first node that starts after the end of the viewport (with buffer)\n    const lastIndex = binarySearch(visibleNodes, (node) => {\n      return node.position - Y_OFFSET > this.y + this.viewportHeight;\n    }, firstIndex);\n\n    const viewportNodes = [];\n\n    // Loading async top nodes' children is too long.\n    // It happens when first node is visible withing viewport range (including Y_OFFSET).\n    // In that case firstIndex == 0 and lastIndex == visibleNodes.length - 1 (e.g. 1000),\n    // which means that it loops through every visibleNodes item and push them into viewportNodes array.\n    // lastIndex should not equal visibleNodes.length - 1, but something around 50-100 (depending on the viewport)\n    const nodeHeight = visibleNodes[0].treeModel.options.options.nodeHeight;\n    const renderedNodesMaxLength = (Y_OFFSET * 2 + this.viewportHeight) / nodeHeight;\n\n    // Something is probably wrong, prevent nodes from being pushed to an array.\n    if (lastIndex - firstIndex > renderedNodesMaxLength) {\n      return [];\n    }\n\n    for (let i = firstIndex; i <= lastIndex; i++) {\n      viewportNodes.push(visibleNodes[i]);\n    }\n\n    return viewportNodes;\n  }\n\n  fixScroll() {\n    const maxY = Math.max(0, this.totalHeight - this.viewportHeight);\n\n    if (this.y < 0) this._setYBlocks(0);\n    if (this.y > maxY) this._setYBlocks(maxY / Y_EPSILON);\n  }\n}\n\nfunction binarySearch(nodes, condition, firstIndex = 0) {\n  let index = firstIndex;\n  let toIndex = nodes.length - 1;\n\n  while (index !== toIndex) {\n    let midIndex = Math.floor((index + toIndex) / 2);\n\n    if (condition(nodes[midIndex])) {\n      toIndex = midIndex;\n    }\n    else {\n      if (index === midIndex) index = toIndex;\n      else index = midIndex;\n    }\n  }\n  return index;\n}\n"]},"metadata":{},"sourceType":"module"}