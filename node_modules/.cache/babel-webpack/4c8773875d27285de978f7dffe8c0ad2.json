{"ast":null,"code":"import * as ɵngcc0 from '@angular/core';\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nimport { Directive, ElementRef, HostListener, Input, NgZone, Renderer2 } from '@angular/core';\nimport { TreeDraggedElement } from '../models/tree-dragged-element.model';\nvar DRAG_OVER_CLASS = 'is-dragging-over';\n\nvar TreeDragDirective =\n/** @class */\nfunction () {\n  function TreeDragDirective(el, renderer, treeDraggedElement, ngZone) {\n    this.el = el;\n    this.renderer = renderer;\n    this.treeDraggedElement = treeDraggedElement;\n    this.ngZone = ngZone;\n    this.dragEventHandler = this.onDrag.bind(this);\n  }\n\n  TreeDragDirective.prototype.ngAfterViewInit = function () {\n    var _this = this;\n\n    var el = this.el.nativeElement;\n    this.ngZone.runOutsideAngular(function () {\n      el.addEventListener('drag', _this.dragEventHandler);\n    });\n  };\n\n  TreeDragDirective.prototype.ngDoCheck = function () {\n    this.renderer.setAttribute(this.el.nativeElement, 'draggable', this.treeDragEnabled ? 'true' : 'false');\n  };\n\n  TreeDragDirective.prototype.ngOnDestroy = function () {\n    var el = this.el.nativeElement;\n    el.removeEventListener('drag', this.dragEventHandler);\n  };\n\n  TreeDragDirective.prototype.onDragStart = function (ev) {\n    // setting the data is required by firefox\n    ev.dataTransfer.setData('text', ev.target.id);\n    this.treeDraggedElement.set(this.draggedElement);\n\n    if (this.draggedElement.mouseAction) {\n      this.draggedElement.mouseAction('dragStart', ev);\n    }\n  };\n\n  TreeDragDirective.prototype.onDrag = function (ev) {\n    if (this.draggedElement.mouseAction) {\n      this.draggedElement.mouseAction('drag', ev);\n    }\n  };\n\n  TreeDragDirective.prototype.onDragEnd = function () {\n    if (this.draggedElement.mouseAction) {\n      this.draggedElement.mouseAction('dragEnd');\n    }\n\n    this.treeDraggedElement.set(null);\n  };\n\n  __decorate([Input('treeDrag'), __metadata(\"design:type\", Object)], TreeDragDirective.prototype, \"draggedElement\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], TreeDragDirective.prototype, \"treeDragEnabled\", void 0);\n\n  __decorate([HostListener('dragstart', ['$event']), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", void 0)], TreeDragDirective.prototype, \"onDragStart\", null);\n\n  __decorate([HostListener('dragend'), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], TreeDragDirective.prototype, \"onDragEnd\", null);\n\n  TreeDragDirective = __decorate([__metadata(\"design:paramtypes\", [ElementRef, Renderer2, TreeDraggedElement, NgZone])], TreeDragDirective);\n\n  TreeDragDirective.ɵfac = function TreeDragDirective_Factory(t) {\n    return new (t || TreeDragDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(TreeDraggedElement), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  TreeDragDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n    type: TreeDragDirective,\n    selectors: [[\"\", \"treeDrag\", \"\"]],\n    hostBindings: function TreeDragDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"dragstart\", function TreeDragDirective_dragstart_HostBindingHandler($event) {\n          return ctx.onDragStart($event);\n        })(\"dragend\", function TreeDragDirective_dragend_HostBindingHandler() {\n          return ctx.onDragEnd();\n        });\n      }\n    },\n    inputs: {\n      draggedElement: [\"treeDrag\", \"draggedElement\"],\n      treeDragEnabled: \"treeDragEnabled\"\n    }\n  });\n  /*@__PURE__*/\n\n  (function () {\n    ɵngcc0.ɵsetClassMetadata(TreeDragDirective, [{\n      type: Directive,\n      args: [{\n        selector: '[treeDrag]'\n      }]\n    }], function () {\n      return [{\n        type: ɵngcc0.ElementRef\n      }, {\n        type: ɵngcc0.Renderer2\n      }, {\n        type: TreeDraggedElement\n      }, {\n        type: ɵngcc0.NgZone\n      }];\n    }, {\n      onDragStart: [{\n        type: HostListener,\n        args: ['dragstart', ['$event']]\n      }],\n      onDragEnd: [{\n        type: HostListener,\n        args: ['dragend']\n      }],\n      draggedElement: [{\n        type: Input,\n        args: ['treeDrag']\n      }],\n      treeDragEnabled: [{\n        type: Input\n      }]\n    });\n  })();\n\n  return TreeDragDirective;\n}();\n\nexport { TreeDragDirective };","map":{"version":3,"sources":["../../lib/directives/tree-drag.directive.ts"],"names":[],"mappings":"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","sourcesContent":["import { AfterViewInit, Directive, DoCheck, ElementRef, HostListener, Input, NgZone, OnDestroy, Renderer2 } from '@angular/core';\nimport { TreeDraggedElement } from '../models/tree-dragged-element.model';\n\nconst DRAG_OVER_CLASS = 'is-dragging-over';\n\n@Directive({\n  selector: '[treeDrag]'\n})\nexport class TreeDragDirective implements AfterViewInit, DoCheck, OnDestroy {\n  @Input('treeDrag') draggedElement;\n  @Input() treeDragEnabled;\n  private readonly dragEventHandler: (ev: DragEvent) => void;\n\n  constructor(private el: ElementRef, private renderer: Renderer2, private treeDraggedElement: TreeDraggedElement, private ngZone: NgZone) {\n    this.dragEventHandler = this.onDrag.bind(this);\n  }\n\n  ngAfterViewInit() {\n    let el: HTMLElement = this.el.nativeElement;\n    this.ngZone.runOutsideAngular(() => {\n      el.addEventListener('drag', this.dragEventHandler);\n    });\n  }\n\n  ngDoCheck() {\n    this.renderer.setAttribute(this.el.nativeElement, 'draggable', this.treeDragEnabled ? 'true' : 'false');\n  }\n\n  ngOnDestroy() {\n    let el: HTMLElement = this.el.nativeElement;\n    el.removeEventListener('drag', this.dragEventHandler);\n  }\n\n  @HostListener('dragstart', ['$event']) onDragStart(ev) {\n    // setting the data is required by firefox\n    ev.dataTransfer.setData('text', ev.target.id);\n    this.treeDraggedElement.set(this.draggedElement);\n    if (this.draggedElement.mouseAction) {\n      this.draggedElement.mouseAction('dragStart', ev);\n    }\n  }\n\n  onDrag(ev) {\n    if (this.draggedElement.mouseAction) {\n      this.draggedElement.mouseAction('drag', ev);\n    }\n  }\n\n  @HostListener('dragend') onDragEnd() {\n    if (this.draggedElement.mouseAction) {\n      this.draggedElement.mouseAction('dragEnd');\n    }\n    this.treeDraggedElement.set(null);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}