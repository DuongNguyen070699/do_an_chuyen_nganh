import { InjectionToken, ɵɵdefineInjectable, ɵɵinject, Injectable, Inject, NgModule } from '@angular/core';
import { __awaiter } from 'tslib';
import { HttpHeaders, HttpClient, HttpClientModule } from '@angular/common/http';
import { Router } from '@angular/router';
import { throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';

const DTGAUTH_CONFIG = new InjectionToken('DTGAuthModuleOptions');

const TOKEN = 'token';
const USER = 'user';
class DTGAuthService {
    constructor(http, config) {
        this.http = http;
        this.config = config;
    }
    authenticate(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const { username, password, appId } = params;
            const url = this.config.loginUrl || this.config.apiUrl + '/auth/login';
            const result = yield this.http.post(url, {
                username, password,
                appId
            }).toPromise();
            if (result) {
                localStorage.setItem(TOKEN, result.accessToken);
                localStorage.setItem(USER, JSON.stringify(result));
            }
            return result;
        });
    }
    isAuthenticate() {
        return Boolean(this.getToken());
    }
    getToken() {
        return localStorage.getItem(TOKEN);
    }
    getInfo() {
        const user = localStorage.getItem(USER);
        if (user) {
            return JSON.parse(user);
        }
        return null;
    }
    deAuthenticate() {
        localStorage.removeItem(TOKEN);
        localStorage.removeItem(USER);
    }
    isAccess(params) {
        const { appId } = params;
        const url = this.config.isAccessUrl ||
            `${this.config.apiUrl}/auth/isaccess/${appId}`;
        return this.http.get(url, {
            headers: {
                Authorization: 'Bearer ' + this.getToken()
            }
        });
    }
    getAppInfo(params) {
        // Get a token from api server using the fetch api
        const { appId, isGuest } = params;
        let url = this.config.appInfoUrl || `${this.config.apiUrl}/auth/appinfo/${appId}`;
        let headers = new HttpHeaders();
        if (!isGuest && this.isAuthenticate()) {
            headers = headers.append('Authorization', 'Bearer ' + this.getToken());
        }
        else {
            url = url + '/anonymous';
        }
        return this.http.get(url, {
            headers
        });
    }
}
DTGAuthService.ɵprov = ɵɵdefineInjectable({ factory: function DTGAuthService_Factory() { return new DTGAuthService(ɵɵinject(HttpClient), ɵɵinject(DTGAUTH_CONFIG)); }, token: DTGAuthService, providedIn: "root" });
DTGAuthService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
DTGAuthService.ctorParameters = () => [
    { type: HttpClient },
    { type: undefined, decorators: [{ type: Inject, args: [DTGAUTH_CONFIG,] }] }
];

class DTGLogService {
    constructor(http, authService, config) {
        this.http = http;
        this.authService = authService;
        this.config = config;
    }
    create(entity) {
        const url = this.config.logUrl || `${this.config.apiUrl}/sys/logger`;
        return this.http.post(url, JSON.stringify(entity), {
            headers: {
                'Content-Type': 'application/json',
                Authorization: 'Bearer ' + this.authService.getToken()
            }
        });
    }
}
DTGLogService.ɵprov = ɵɵdefineInjectable({ factory: function DTGLogService_Factory() { return new DTGLogService(ɵɵinject(HttpClient), ɵɵinject(DTGAuthService), ɵɵinject(DTGAUTH_CONFIG)); }, token: DTGLogService, providedIn: "root" });
DTGLogService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
DTGLogService.ctorParameters = () => [
    { type: HttpClient },
    { type: DTGAuthService },
    { type: undefined, decorators: [{ type: Inject, args: [DTGAUTH_CONFIG,] }] }
];

class DTGLayerInfoService {
    constructor(http, authService, config) {
        this.http = http;
        this.authService = authService;
        this.config = config;
    }
    get() {
        const url = this.config.layerInfoUrl ||
            `${this.config.apiUrl}/auth/layerinfos`;
        return this.http.get(url, {
            headers: {
                Authorization: 'Bearer ' + this.authService.getToken()
            }
        });
    }
    getGuest() {
        const url = this.config.layerInfoUrl ||
            `${this.config.apiUrl}/auth/layerinfos/anonymous`;
        return this.http.get(url);
    }
}
DTGLayerInfoService.ɵprov = ɵɵdefineInjectable({ factory: function DTGLayerInfoService_Factory() { return new DTGLayerInfoService(ɵɵinject(HttpClient), ɵɵinject(DTGAuthService), ɵɵinject(DTGAUTH_CONFIG)); }, token: DTGLayerInfoService, providedIn: "root" });
DTGLayerInfoService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
DTGLayerInfoService.ctorParameters = () => [
    { type: HttpClient },
    { type: DTGAuthService },
    { type: undefined, decorators: [{ type: Inject, args: [DTGAUTH_CONFIG,] }] }
];

class DTGSimpleGuard {
    constructor(authService, router, config) {
        this.authService = authService;
        this.router = router;
        this.config = config;
    }
    canActivate(route, state) {
        const isAuthenticate = this.authService.isAuthenticate();
        if (isAuthenticate) {
            // logged in so return true
            if (this.config.guard && this.config.guard.simple) {
                if (this.config.guard.simple.canActive) {
                    this.config.guard.simple.canActive(route, state);
                }
            }
            return true;
        }
        // not logged in so redirect to login page with the return url
        if (this.config.guard && this.config.guard.simple) {
            if (this.config.guard.simple.canNotActive) {
                this.config.guard.simple.canNotActive(route, state);
                return false;
            }
        }
        this.router.navigateByUrl(this.config.guard &&
            this.config.guard.simple && this.config.guard.simple.defaultNavigateUrl ?
            this.config.guard.simple.defaultNavigateUrl :
            '/auth', { queryParams: { returnUrl: state.url } });
        return false;
    }
}
DTGSimpleGuard.ɵprov = ɵɵdefineInjectable({ factory: function DTGSimpleGuard_Factory() { return new DTGSimpleGuard(ɵɵinject(DTGAuthService), ɵɵinject(Router), ɵɵinject(DTGAUTH_CONFIG)); }, token: DTGSimpleGuard, providedIn: "root" });
DTGSimpleGuard.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
DTGSimpleGuard.ctorParameters = () => [
    { type: DTGAuthService },
    { type: Router },
    { type: undefined, decorators: [{ type: Inject, args: [DTGAUTH_CONFIG,] }] }
];

class DitagisAuthModule {
    static forRoot(options) {
        return {
            ngModule: DitagisAuthModule,
            providers: [
                { provide: DTGAUTH_CONFIG, useValue: options },
                DTGAuthService, DTGLogService, DTGLayerInfoService, DTGSimpleGuard
            ]
        };
    }
}
DitagisAuthModule.decorators = [
    { type: NgModule, args: [{
                declarations: [],
                imports: [
                    HttpClientModule
                ]
            },] }
];

var ApplicationEnvironmentEnum;
(function (ApplicationEnvironmentEnum) {
    ApplicationEnvironmentEnum["Desktop"] = "D";
    ApplicationEnvironmentEnum["Web"] = "W";
    ApplicationEnvironmentEnum["Mobile"] = "M";
})(ApplicationEnvironmentEnum || (ApplicationEnvironmentEnum = {}));

class ResponseLogin {
}

var ColumnTypeEnum;
(function (ColumnTypeEnum) {
    ColumnTypeEnum["string"] = "esriFieldTypeString";
    ColumnTypeEnum["smallInteger"] = "esriFieldTypeSmallInteger";
    ColumnTypeEnum["integer"] = "esriFieldTypeInteger";
    ColumnTypeEnum["double"] = "esriFieldTypeDouble";
    ColumnTypeEnum["long"] = "esriFieldTypeLong";
    ColumnTypeEnum["date"] = "esriFieldTypeDate";
    ColumnTypeEnum["oid"] = "esriFieldTypeOID";
    ColumnTypeEnum["geometry"] = "esriFieldTypeGeometry";
})(ColumnTypeEnum || (ColumnTypeEnum = {}));

var LoggerActionTypeEnum;
(function (LoggerActionTypeEnum) {
    LoggerActionTypeEnum["INSERT"] = "INSERT";
    LoggerActionTypeEnum["LOGIN"] = "LOGIN";
    LoggerActionTypeEnum["LOGOUT"] = "LOGOUT";
    LoggerActionTypeEnum["REMOVE"] = "REMOVE";
    LoggerActionTypeEnum["UPDATE"] = "UPDATE";
})(LoggerActionTypeEnum || (LoggerActionTypeEnum = {}));

var UserStatusEnum;
(function (UserStatusEnum) {
    UserStatusEnum["Open"] = "OPEN";
    UserStatusEnum["Locked"] = "LOCKED";
    UserStatusEnum["Request"] = "REQUEST";
    UserStatusEnum["Expired"] = "EXPIRED";
})(UserStatusEnum || (UserStatusEnum = {}));
var RoleStatusEnum;
(function (RoleStatusEnum) {
    RoleStatusEnum["Open"] = "OPEN";
    RoleStatusEnum["Lock"] = "LOCK";
    RoleStatusEnum["Hide"] = "HIDE";
})(RoleStatusEnum || (RoleStatusEnum = {}));

class ErrorInterceptor {
    constructor(authService, config) {
        this.authService = authService;
        this.config = config;
    }
    intercept(request, next) {
        return next.handle(request).pipe(catchError(err => {
            const url = this.config && this.config.loginUrl || 'login';
            if (request.url.search(url) === -1) {
                if (err.status === 401) {
                    // auto logout if 401 response returned from api
                    this.authService.deAuthenticate();
                    location.reload(true);
                }
            }
            const error = err.error.message || err.statusText || 'Có lỗi xảy ra';
            return throwError(error);
        }));
    }
}
ErrorInterceptor.ɵprov = ɵɵdefineInjectable({ factory: function ErrorInterceptor_Factory() { return new ErrorInterceptor(ɵɵinject(DTGAuthService), ɵɵinject(DTGAUTH_CONFIG)); }, token: ErrorInterceptor, providedIn: "root" });
ErrorInterceptor.decorators = [
    { type: Injectable, args: [{ providedIn: 'root', deps: [DTGAuthService] },] }
];
ErrorInterceptor.ctorParameters = () => [
    { type: DTGAuthService },
    { type: undefined, decorators: [{ type: Inject, args: [DTGAUTH_CONFIG,] }] }
];

class JwtInterceptor {
    constructor(authService) {
        this.authService = authService;
    }
    intercept(request, next) {
        // add authorization header with jwt token if available
        const isAuthenticate = this.authService.isAuthenticate();
        if (isAuthenticate) {
            const token = this.authService.getToken();
            request = request.clone({
                setHeaders: {
                    Authorization: `Bearer ${token}`
                }
            });
        }
        return next.handle(request);
    }
}
JwtInterceptor.ɵprov = ɵɵdefineInjectable({ factory: function JwtInterceptor_Factory() { return new JwtInterceptor(ɵɵinject(DTGAuthService)); }, token: JwtInterceptor, providedIn: "root" });
JwtInterceptor.decorators = [
    { type: Injectable, args: [{ providedIn: 'root', deps: [DTGAuthService] },] }
];
JwtInterceptor.ctorParameters = () => [
    { type: DTGAuthService }
];

/*
 * Public API Surface of ditagis-auth
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ApplicationEnvironmentEnum, ColumnTypeEnum, DTGAUTH_CONFIG, DTGAuthService, DTGLayerInfoService, DTGLogService, DTGSimpleGuard, DitagisAuthModule, ErrorInterceptor, JwtInterceptor, LoggerActionTypeEnum, ResponseLogin, RoleStatusEnum, UserStatusEnum, DTGLogService as ɵa, DTGLayerInfoService as ɵb, DTGSimpleGuard as ɵc };
//# sourceMappingURL=ditagis-auth.js.map
